@implements IAsyncDisposable
@using BrickBreaker.WebClient.Services
@using Microsoft.AspNetCore.Components.Web
@using Microsoft.JSInterop
@inject IJSRuntime JS

<div class="game-shell">
    <div class="game-surface">
        <canvas class="game-canvas"
                @ref="_canvasRef"
                tabindex="0"
                @onblur="HandleBlur">
        </canvas>
    </div>

</div>

@code {
    [Parameter] public EventCallback<int> OnGameFinished { get; set; }
    [Parameter] public EventCallback<GameStatusSnapshot> OnStateChanged { get; set; }

    private ElementReference _canvasRef;
    private WebGameHost? _host;
    private IJSObjectReference? _inputModule;
    private DotNetObjectReference<GameCanvas>? _dotNetRef;
    private bool _inputHandlersAttached;

    protected override void OnInitialized()
    {
        _host = new WebGameHost(JS);
        _host.StateChanged += HandleStateChanged;
        _host.GameFinished += HandleHostGameFinished;
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            if (_host is not null)
            {
                await _host.InitializeAsync(_canvasRef);
                await _canvasRef.FocusAsync();
            }

            await AttachInputHandlersAsync();
        }
    }

    private async Task AttachInputHandlersAsync()
    {
        if (_inputHandlersAttached)
        {
            return;
        }

        _inputModule ??= await JS.InvokeAsync<IJSObjectReference>("import", "./js/gameInput.js");
        _dotNetRef ??= DotNetObjectReference.Create(this);
        await _inputModule.InvokeVoidAsync("attachInputHandlers", _dotNetRef);
        _inputHandlersAttached = true;
    }

    private async void HandleStateChanged()
    {
        await InvokeAsync(async () =>
        {
            if (_host is not null && OnStateChanged.HasDelegate)
            {
                var snapshot = new GameStatusSnapshot(_host.Score, _host.Level, _host.ActiveBalls, _host.IsPaused, _host.IsGameOver, _host.BallReady);
                await OnStateChanged.InvokeAsync(snapshot);
            }

            StateHasChanged();
        });
    }

    private Task HandleKeyDown(KeyboardEventArgs args)
    {
        if (_host is null)
        {
            return Task.CompletedTask;
        }

        switch (args.Key)
        {
            case "ArrowLeft":
            case "a":
            case "A":
                _host.SetLeftPressed(true);
                break;
            case "ArrowRight":
            case "d":
            case "D":
                _host.SetRightPressed(true);
                break;
            case "ArrowUp":
            case "w":
            case "W":
                _host.TryLaunchBall();
                break;
            case " ":
                _host.TogglePause();
                break;
            case "Enter":
            case "NumpadEnter":
                if (_host.IsGameOver)
                {
                    _host.Restart();
                }
                break;
        }

        return Task.CompletedTask;
    }

    private Task HandleKeyUp(KeyboardEventArgs args)
    {
        if (_host is null)
        {
            return Task.CompletedTask;
        }

        switch (args.Key)
        {
            case "ArrowLeft":
            case "a":
            case "A":
                _host.SetLeftPressed(false);
                break;
            case "ArrowRight":
            case "d":
            case "D":
                _host.SetRightPressed(false);
                break;
        }

        return Task.CompletedTask;
    }

    private void HandleBlur()
    {
        _host?.ClearInput();
    }

    private void TogglePause()
    {
        _host?.TogglePause();
    }

    private void Restart()
    {
        _host?.Restart();
    }

    public async ValueTask DisposeAsync()
    {
        if (_host is not null)
        {
            _host.StateChanged -= HandleStateChanged;
            _host.GameFinished -= HandleHostGameFinished;
            await _host.DisposeAsync();
        }

        if (_inputModule is not null)
        {
            if (_inputHandlersAttached)
            {
                await _inputModule.InvokeVoidAsync("detachInputHandlers");
                _inputHandlersAttached = false;
            }

            await _inputModule.DisposeAsync();
        }

        _dotNetRef?.Dispose();
    }

    private async void HandleHostGameFinished(int score)
    {
        if (OnGameFinished.HasDelegate)
        {
            await InvokeAsync(() => OnGameFinished.InvokeAsync(score));
        }
    }

    [JSInvokable]
    public Task HandleGlobalKeyDown(string key)
        => HandleKeyDown(new KeyboardEventArgs { Key = key });

    [JSInvokable]
    public Task HandleGlobalKeyUp(string key)
        => HandleKeyUp(new KeyboardEventArgs { Key = key });
}
