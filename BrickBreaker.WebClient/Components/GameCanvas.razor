@implements IAsyncDisposable
@using BrickBreaker.WebClient.Services
@inject IJSRuntime JS

<div class="game-shell">
    <canvas class="game-canvas"
            @ref="_canvasRef"
            tabindex="0"
            @onkeydown="HandleKeyDown"
            @onkeyup="HandleKeyUp"
            @onblur="HandleBlur"
            @onkeydown:preventDefault
            @onkeyup:preventDefault>
    </canvas>

    @if (_host is not null)
    {
        <div class="status">
            @if (_host.IsGameOver)
            {
                <span>Game over! Press Space or Restart.</span>
            }
            else if (_host.IsPaused)
            {
                <span>Paused</span>
            }
            else if (_host.BallReady)
            {
                <span>Press â†‘ / W to launch the ball.</span>
            }
        </div>
    }

    <div class="controls">
        <button @onclick="TogglePause" disabled="@(_host is null)">
            @((_host?.IsPaused ?? false) ? "Resume" : "Pause")
        </button>
        <button @onclick="Restart" disabled="@(_host is null)">Restart</button>
    </div>
</div>

@code {
    [Parameter] public EventCallback<int> OnGameFinished { get; set; }
    [Parameter] public EventCallback<GameStatusSnapshot> OnStateChanged { get; set; }

    private ElementReference _canvasRef;
    private WebGameHost? _host;

    protected override void OnInitialized()
    {
        _host = new WebGameHost(JS);
        _host.StateChanged += HandleStateChanged;
        _host.GameFinished += HandleHostGameFinished;
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && _host is not null)
        {
            await _host.InitializeAsync(_canvasRef);
            await _canvasRef.FocusAsync();
        }
    }

    private async void HandleStateChanged()
    {
        await InvokeAsync(async () =>
        {
            if (_host is not null && OnStateChanged.HasDelegate)
            {
                var snapshot = new GameStatusSnapshot(_host.Score, _host.Level, _host.ActiveBalls, _host.IsPaused, _host.IsGameOver, _host.BallReady);
                await OnStateChanged.InvokeAsync(snapshot);
            }

            StateHasChanged();
        });
    }

    private Task HandleKeyDown(KeyboardEventArgs args)
    {
        if (_host is null)
        {
            return Task.CompletedTask;
        }

        switch (args.Key)
        {
            case "ArrowLeft":
            case "a":
            case "A":
                _host.SetLeftPressed(true);
                break;
            case "ArrowRight":
            case "d":
            case "D":
                _host.SetRightPressed(true);
                break;
            case "ArrowUp":
            case "w":
            case "W":
                _host.TryLaunchBall();
                break;
            case " ":
                if (_host.IsGameOver)
                {
                    _host.Restart();
                }
                else
                {
                    _host.TryLaunchBall();
                }
                break;
            case "p":
            case "P":
                _host.TogglePause();
                break;
        }

        return Task.CompletedTask;
    }

    private Task HandleKeyUp(KeyboardEventArgs args)
    {
        if (_host is null)
        {
            return Task.CompletedTask;
        }

        switch (args.Key)
        {
            case "ArrowLeft":
            case "a":
            case "A":
                _host.SetLeftPressed(false);
                break;
            case "ArrowRight":
            case "d":
            case "D":
                _host.SetRightPressed(false);
                break;
        }

        return Task.CompletedTask;
    }

    private void HandleBlur()
    {
        _host?.ClearInput();
    }

    private void TogglePause()
    {
        _host?.TogglePause();
    }

    private void Restart()
    {
        _host?.Restart();
    }

    public async ValueTask DisposeAsync()
    {
        if (_host is not null)
        {
            _host.StateChanged -= HandleStateChanged;
            _host.GameFinished -= HandleHostGameFinished;
            await _host.DisposeAsync();
        }
    }

    private async void HandleHostGameFinished(int score)
    {
        if (OnGameFinished.HasDelegate)
        {
            await InvokeAsync(() => OnGameFinished.InvokeAsync(score));
        }
    }
}
